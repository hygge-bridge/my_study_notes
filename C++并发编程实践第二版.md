# 第一章 你好，C++并发世界

## 1.1 什么是并发

### 1.1.1 计算机系统中的并发

#### **并发**：

两个或多个**同时独立**进行的活动，例如边走路边说话

#### 计算机系统的并发：

同一个系统中，多个独立活动同时进行，而非依次进行。

**并发影响因素：**硬件真正**支持同时运行的独立任务**的数量。所以有些处理器也可以在单核上执行多线程

#### 硬件并发:

无论装配多个处理器，还是单个多核处理器，或是多个多核处理器，这些计算机能**真正并行**运作多个任务

#### 上下文切换：

**背景**：为了交替执行，每当系统从一个任务切换到另一个，就必须完成一次上下文切换。

 **内容**：os需要保存当当前任务的**CPU状态和指令指针**，判定需要切换到那个任务，并为之**重新加载CPU**。

**并发带来的弊端：**CPU可能需要将**新任务的指令和数据从内存加载到缓存**，这或许会**妨碍CPU**，令其无法执行任何指令，加剧延迟

### 1.1.2 并发的方式

#### 1 多进程并发

将一个应用软件**拆分成多个独立进程**同时运行，它们都**只含单一线程**，非常类似于同时运行浏览器和文字处理软件。

![image-20230708073346217](C:\Users\Mr.Helen\AppData\Roaming\Typora\typora-user-images\image-20230708073346217.png)

这种方式必须通过常规的进程间通信途径传递信息。C++本身不支持进程间通信，需要借助API。

**缺点：**

- 设置复杂，或速度慢，甚至二者兼有，因为操作系统往往要在进程之间提供大量防护措施，以免某进程意外改动另一个进程的数据；
- 运行多个进程的固定开销大，进程的启动花费时间，操作系统必须调配内部资源来管控进程

**优点：**

- 安全
- 通过网络连接，独立的进程可以在不同计算机上运行

### 2 多线程并发

单一进程内运行多线程

**线程非常像轻量级进程**：每个线程都**独立运行**，并能各自执行不同的指令序列。

**特点**：

- 同一进程内的所有线程都共用相同的地址空间，且所有线程都能直接访问大部分数据。
- 全局变量依然全局可见，指向对象或数据的指针和引用能在线程间传递

![image-20230708074130794](C:\Users\Mr.Helen\AppData\Roaming\Typora\typora-user-images\image-20230708074130794.png)

### 1.1.3 并发与并行

两个术语都是指使用**可调配的硬件资源同时运行多个任务**，但**并行更强调性能**。

- **并行**更关注利用可调配的硬件资源**提升大规模数据处理的性能**
- **并发**更关注**分离关注点或响应能力**

## 1.2 为什么使用并发技术

### 1.2.1 为分离关注点而并发

**分离关注点**：**归类相关代码，隔离无关代码**，使程序更易于理解和测试，因此所含缺陷很可能更少。例如一个线程负责听，一个线程负责说，两个线程之间**只保留必要的交互**。

### 1.2.2 为性能而并发：任务并行和数据并行

1、尴尬并行算法（主要是因为这种方法很简单）：

**任务并行**：将单一任务分解成多个部分，各自并行运作，从而节省总运行耗时

**数据并行**：针对数据，线程分别对数据的不同部分执行同样的操作

2、利用**并行资源**解决规模更大的问题。例如只要条件适合，便同时处理多个文件，而不是每次1个。

核心就是数据并行，但是有别于任务并行。

采用这种方式**处理单一数据**所需的**时间依旧不变**，而同等时间内能处理的数据相对更多。

### 1.2.3 什么时候避免并发

- 编写正确运行的多线程代码需要**额外的开发时间和相关维护成本**，除非潜在的性能提升或分离关注点而提高的清晰度值得这些开销，否则别使用并发技术。
- **线程的启动存在固有开销**，因为系统须妥善分配相关的**内核资源和栈空间**，这是会耗费时间的。如果**处理任务本身的时间远短于线程启动的时间**就不要并发了。
- **线程是一种有限的资源**。若一次运行太多线程，便会消耗操作系统资源，可能令系统整体变慢。例如服务端每处理一个连接就创建一个线程，那请求量太大了，系统资源一下就没了。
- 线程过多，**上下文切换就越麻烦**，耗时越多，每次切换都会减少真正实质工作的实践。

## 1.3 并发与C++多线程

### 1.3.1 C++多线简史

**C++大多数类的特性：**通过资源获取即初始化（RAII）进行锁操作，确保了一旦脱离作用域，锁的互斥就会被解开。

**RAII:**使用**局部对象**来管理资源的技术称为资源获取即初始化。说白了就是，让构造函数初始化，析构函数释放资源。因为局部对象退出作用域的时候，会自动调用析构函数。

### 1.3.2 - 1.3.5了解就行，没啥笔记

## 1.4 启程上路

```
#include <iostream>
#include <thread>

void hello() {
	std::cout << "Hello Concurrent World\n";
}

int main() {
	std::thread t(hello);
	t.join();
	return 0;
}
```



- 每个线程都需要一个**起始函数**（initial function），**新线程从起始函数开始执行**。应用程序的起始函数就是main，其他线程的其实函数需要在thread对象的构造函数中指明。
- 如果起始线程（指应用程序的起始线程，main)不等待新线程结束，就会一路执行，直到main()结束，甚至很可能直接终止整个程序，新线程根本没有机会启动。**join会令主线程等待子线程**，前者调用main，后者与thread对象相关，例如本例中的t。

# 附录A C++11精要：部分语言特性

## A.1 右值引用

**左值：**可在赋值表达式**等号左边**出现的元素，包括具名对象、在栈数据段和堆数据段上分配的对象、其他对象的数据成员，或**一切具有确定存储范围的数据项**。（ps：堆栈是内存空间上的，对象不是面向对象的对象）

**右值：**只能在赋值表达式**等号右边**出现的元素，如字面值和临时变量。

```
//1 + 2的结果是临时变量，为右值
int a = 1 + 2;	
```

左值引用只可以绑定左值，例如如下无法编译

```
int& i = 42;
//一般可以将右值绑定到左值引用上
int const& i = 42
```

早期C++不支持右值引用，但是支持通过隐式转换向传引用的函数传入右值，这是破例了。

```
void print(std::string const& s);
print("hello");    ⇽---  ①创建std::string类型的临时变量
```

右值引用使用举例

```
int&& i = 42;	//√
int j = 42;		
int&& k = j;	//编译失败
```

### A.1.1　移动语义

只需移动右值参数而不必复制本体

